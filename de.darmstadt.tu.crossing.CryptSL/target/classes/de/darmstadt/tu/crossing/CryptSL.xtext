grammar de.darmstadt.tu.crossing.CryptSL with org.eclipse.xtext.xbase.Xtype

generate cryptSL "http://www.darmstadt.de/tu/crossing/CryptSL"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

Domainmodel:
	'SPEC' javaType=[jvmTypes::JvmType|QualifiedName]
	'USES_OBJECTS' (usage=UseBlock)
	('FORBIDDEN_EVENTS' forbEvent=ForbiddenBlock)?
	'REQUIRED_EVENTS' (req_events=RequiredBlock)
	'ENFORCE_ORDER' order=Order
	('ENFORCES_CONSTRAINTS' reqConstraints=EnforceConsBlock)?
	('ENSURES' ensure=EnsuresBlock)?
	;

UseBlock:
	objects+=(ObjectDecl)+
;

ForbiddenBlock:
	forb_methods+=(ForbMethod)+
;

RequiredBlock:
	req_event+=(Event)+
;

EnforceConsBlock:
	(req+=Constraint  ';')+
;


EnsuresBlock:
	(pred+=Pred ';')+
;

	////////////// OBJECTS
ObjectDecl:
	objectType=[jvmTypes::JvmType|QualifiedName] (array="[]")? objectName=Object ";";

	/////////// FORBIDDEN EVENTS
ForbMethod:
	(javaMeth=[jvmTypes::JvmExecutable|FQN] ("=>" rep=[Event])?) ';';

FQN:
	QN "(" (QN ("," QN)*)? ")";

QN:
	ID ('.' ID)* ("[]")?;

	///////////// EVENTS
Event:
	LabelMethodCall | Aggregate;

	/// LABELMETHCALL
LabelMethodCall returns SuperType:
	name=ID ":" meth=Method;

Method:
	(leftSide=[Object] "=")? methName=[jvmTypes::JvmExecutable|ID] "(" parList=ParList? ");";

ParList:
	(parameters+=Par (',' parameters+=Par)*);

Par:
	{Par} (val=[Object] | '_');

	/// AGGS
Aggregate returns SuperType:
	{Aggregate} (name=ID ':=' (lab+=[Event] (',' lab+=[Event])*) ";");

	///////////// ORDER
Order returns Expression:
	SimpleOrder ({Order.left=current} orderop=',' right=SimpleOrder)*;

SimpleOrder returns Expression:
	Primary ({SimpleOrder.left=current} orderop='|' right=Primary)*;

Primary returns Expression:
	(orderEv+=[Event] elementop=('+' | '?' | '*')?) | ('(' Order ')' elementop=('+' | '?' | '*')?);

	///////////// CONSTRAINTS
Constraint:
	LogicalImplyExpression;

LogicalImplyExpression returns Constraint:
	LogicalOrExpression
	({Constraint.leftExpression=current}
	operator=LogicalImply
	rightExpression=LogicalOrExpression)*;

LogicalImply:
	IMPLIES="=>";

LogicalOrExpression returns Constraint:
	LogicalAndExpression
	({Constraint.leftExpression=current}
	operator=LogicalOr
	rightExpression=LogicalAndExpression)*;

LogicalOr returns LogicalOperator:
	OR='||';

LogicalAndExpression returns Constraint:
	(ComparisonExpression
	({Constraint.leftExpression=current}
	operator=LogicalAnd
	rightExpression=ComparisonExpression)*);

LogicalAnd returns LogicalOperator:
	AND='&&';

ComparisonExpression returns Constraint:
	ComparisonHigherOpExpression
	({ComparisonExpression.leftExpression=current}
	operator=ComparingEQNEQOperator
	rightExpression=ComparisonHigherOpExpression)?;

ComparisonHigherOpExpression returns Constraint:
	ArithmeticExpression
	({ComparisonExpression.leftExpression=current}
	operator=ComparingRelOperator
	rightExpression=ArithmeticExpression)?;

ComparingRelOperator returns ComparingOperator:
	LESS='<' | LESS_OR_EQUAL='<=' | GREATER_OR_EQUAL='>=' | GREATER='>';

ArithmeticExpression returns Constraint:
	AdditionExpression;

AdditionExpression returns Constraint:
	MultiplicationExpression
	({ArithmeticExpression.leftExpression=current}
	operator=AdditionOperator
	rightExpression=MultiplicationExpression)*;

AdditionOperator returns ArithmeticOperator:
	PLUS='+' | MINUS='-';

MultiplicationExpression returns Constraint:
	UnaryPreExpression
	|
	Operand
	({ArithmeticExpression.leftExpression=current}
	operator=MultiplicationOperator
	rightExpression=Operand)*;

MultiplicationOperator returns ArithmeticOperator:
	TIMES='*' | DIVIDE='/';

UnaryPreExpression returns Constraint:
	{UnaryPreExpression}
	(operator=UnaryPreOperator
	enclosedExpression=Operand);

Operand returns Constraint:
	'(' Constraint ')'
	|
	Cons
	|
	Pred;

LiteralExpression returns LiteralExpression:
	name=Literal | name=AggregateExpression | PreDefinedPredicates 
	;

PreDefinedPredicates:
	predName= "neverTypeOf"+ "(" obj+=[Object] "," type=[jvmTypes::JvmType|QualifiedName] ")" | 
	predName= "noCallTo" + "(" obj+=[Event] ")" |
	predName= "callTo" + "(" obj+=[Event] ")"
;

AggregateExpression returns LiteralExpression:
	value=[SuperType] ("." ID)?;

Literal:
	{Literal} val=(StringLiteral | IntegerLiteral);

StringLiteral:
	STRING;

IntegerLiteral:
	INT;

UnaryPreOperator returns UnaryOperator:
	NOT='!';

ComparingEQNEQOperator returns ComparingOperator:
	EQUAL='==' | UNEQUAL='!=';

Cons returns LiteralExpression:
	cons=ConsPred "in" "{" litsleft=LitList "}" | cons=LiteralExpression;

ConsPred returns LiteralExpression:
	(part= "part(" ind = IntegerLiteral "," split=StringLiteral "," lit = LiteralExpression ")") | lit = LiteralExpression;

terminal INT:
	'0'..'9' ('0'..'9' | '_')*;

LitList:
	(parameters+=Literal (',' (parameters+=Literal | '...'))*);

Pred returns Constraint:
	predName=ID '[' parList=SuParList? ']';

SuParList:
	(parameters+=SuPar (',' parameters+=SuPar)*);

SuPar:
	{SuPar} (val=ConsPred | '_' | 'this');

Object returns SuperType:
	{Object} name=ID;
