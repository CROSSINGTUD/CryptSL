grammar de.darmstadt.tu.crossing.CryptSL with org.eclipse.xtext.xbase.Xbase

generate cryptSL "http://www.darmstadt.de/tu/crossing/CryptSL"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

Domainmodel:
	'SPEC' javaType=[jvmTypes::JvmType|QualifiedName]
	'USES_OBJECTS' (object+=ObjectDecl)+
	('FORBIDDEN_EVENTS' (method+=ForbMethod)+)?
	'REQUIRED_EVENTS' (event+=Event)+
	'ENFORCE_ORDER' order=Order
	'ENFORCES_CONSTRAINTS' (req+=Constraint)*
	('ENSURES' (ens+=Pred)+)?;

ObjectDecl:
	objectType=[jvmTypes::JvmType|QualifiedName] ArrayBrackets? objectName=Object ";";

Event:
	LabelMethodCall | Aggregate;

ForbMethod:
	{ForbMethod} (ID "(" (parameters+=[jvmTypes::JvmType|QualifiedName] ArrayBrackets? 
		(',' parameters+=[jvmTypes::JvmType|QualifiedName] ("[]")?)*)? ")" ("=>" rep=[Event])?);

LabelMethodCall:
	name=ID ":" meth=Method;

Method:
	(leftSide=[Object] "=")? methName=ID "(" parList=ParList? ");";

ParList:
	(parameters+=Par (',' parameters+=Par)*);

Par:
	{Par} (val=[Object] | '_');

Aggregate:
	name=ID ':=' (lab+=[Event] (',' lab+=[Event])*) ";";

Order returns Expression:
	SimpleOrder ({Order.left=current} ',' right=SimpleOrder)*;

SimpleOrder returns Expression:
	Primary ({SimpleOrder.left=current} '|' right=Primary)*;

Primary returns Expression:
	orderEv+=[Event] ('+' | '?' | '*')? | '(' Order ')' ('+' | '?' | '*')?;

Constraint:
	(cons+=Comp | cons+=Incl | ('!')? cons+=Pred);

Incl returns Constraint:
	algl=ConsList ("=>" algr=ConsList)?
;

ConsList:
	list+=Cons (LogCon list+=Cons)*
;

LogCon:
	OpAnd | OpOr
;

Cons:
	cons= ConsPred "in" "{" litsleft=LitList "}"| NoEq
;

NoEq:
	(left=ObAc NoEqOp right=ObAc | left=ObAc NoEqOp (STRING | INT) | (STRING | INT) NoEqOp right=ObAc)
;

NoEqOp:
 '!='	
;

ConsPred:
	("part(" INT "," STRING ")" "of")? name=[Object] 
;

LitList:
	(parameters+=XLiteral (',' (parameters+=XLiteral | '...'))*);

Pred returns Constraint:
	(leftSide=[Object] "=")? predName=ID "(" parList=ParList? ");";

Comp returns Constraint:
	(left=ObAc OpCompare right=ObAc | left=ObAc OpCompare (STRING | INT) | (STRING | INT) OpCompare right=ObAc) ";";

ObAc:
	name=[Object] ("." ID)?
;

Object:
	{Object} name=ID;