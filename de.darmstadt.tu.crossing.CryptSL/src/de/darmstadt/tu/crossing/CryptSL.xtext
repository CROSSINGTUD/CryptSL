grammar de.darmstadt.tu.crossing.CryptSL with org.eclipse.xtext.xbase.Xbase

generate cryptSL "http://www.darmstadt.de/tu/crossing/CryptSL"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

Domainmodel:
	'SPEC' javaType=[jvmTypes::JvmType|QualifiedName]
	'USES_OBJECTS' (object+=ObjectDecl)+
	('FORBIDDEN_EVENTS' (method+=ForbMethod)+)?
	'REQUIRED_EVENTS' (event+=Event)+
	'ENFORCE_ORDER' order=Order
	'ENFORCES_CONSTRAINTS' (req+=Constraint)*
	('ENSURES' (ens+=Pred)+)?;

////////////// OBJECTS
ObjectDecl:
	objectType=[jvmTypes::JvmType|QualifiedName] "[]"? objectName=Object ";";

/////////// FORBIDDEN EVENTS
ForbMethod:
	{ForbMethod} (ID "(" (parameters+=[jvmTypes::JvmType|QualifiedName] "[]"? 
		(',' parameters+=[jvmTypes::JvmType|QualifiedName] ("[]")?)*)? ")" ("=>" rep=[Event])?);

///////////// EVENTS
Event:
	LabelMethodCall | Aggregate;

/// LABELMETHCALL
LabelMethodCall:
	name=ID ":" meth=Method;

Method:
	(leftSide=[Object] "=")? methName=ID "(" parList=ParList? ");";

ParList:
	(parameters+=Par (',' parameters+=Par)*);

Par:
	{Par} (val=[Object] | '_');

/// AGGS
Aggregate returns SuperType:
	{Aggegate}(name=ID ':=' (lab+=[Event] (',' lab+=[Event])*) ";");

///////////// ORDER
Order returns Expression:
	SimpleOrder ({Order.left=current} ',' right=SimpleOrder)*;

SimpleOrder returns Expression:
	Primary ({SimpleOrder.left=current} '|' right=Primary)*;

Primary returns Expression:
	orderEv+=[Event] ('+' | '?' | '*')? | '(' Order ')' ('+' | '?' | '*')?;

///////////// CONSTRAINTS
Constraint:
	LogicalImplyExpression
;

LogicalImplyExpression returns Constraint:
	LogicalOrExpression
	(
		{Constraint.leftExpression=current}
		operator=LogicalImply
		rightExpression=LogicalOrExpression
	)*
;

LogicalImply:
	IMPLIES="=>"
;
LogicalOrExpression returns Constraint:
	LogicalAndExpression 
	(
		{Constraint.leftExpression=current}
		operator=LogicalOr
		rightExpression=LogicalAndExpression
	)*
;

LogicalOr returns LogicalOperator:
	OR='||'
;

LogicalAndExpression returns Constraint:

	(ComparisonExpression 
	(
		{Constraint.leftExpression=current}
		operator=LogicalAnd
		rightExpression=ComparisonExpression
	)*)
;


LogicalAnd returns LogicalOperator:
	AND='&&'
;

ComparisonExpression returns Constraint:
	ComparisonHigherOpExpression 
	(
		{ComparisonExpression.left=current}
		operator=ComparingEQNEQOperator
		rightExpression=ComparisonHigherOpExpression
	)?
;


ComparisonHigherOpExpression returns Constraint:
	ArithmeticExpression
	(
		{ComparisonExpression.leftExpression=current}
		operator=ComparingRelOperator
		rightExpression=ArithmeticExpression
	)?
;

ComparingRelOperator returns ComparingOperator:
	LESS='<' | LESS_OR_EQUAL='<=' | GREATER_OR_EQUAL='>=' | GREATER='>'
;

ArithmeticExpression returns Constraint:
	AdditionExpression
;

AdditionExpression returns Constraint:
	MultiplicationExpression
	(
		{ArithmeticExpression.leftExpression=current} 
		operator=AdditionOperator
		rightExpression=MultiplicationExpression
	)*
;

AdditionOperator returns ArithmeticOperator:
	PLUS='+' | MINUS='-'
;

MultiplicationExpression returns Constraint:
	UnaryPreExpression
	|
	Operand
	 
	(
		{ArithmeticExpression.leftExpression=current}
		operator=MultiplicationOperator
		rightExpression=Operand
	)*
;

MultiplicationOperator returns ArithmeticOperator:
	TIMES='*' | DIVIDE='/'
;

UnaryPreExpression returns Constraint:
	{UnaryPreExpression} 
	(operator=UnaryPreOperator
	enclosedExpression=Operand)
;

Operand returns Constraint:
	'(' Constraint ')' 
	| 
	Cons
	|
	Pred
;

LiteralExpression returns LiteralExpression:
	  Literal | AggregateExpression 	  
;

AggregateExpression returns LiteralExpression:
	 value = [SuperType]("." ID)?
;

Literal returns LiteralExpression:
	 {Literal}(INT | STRING)
;

UnaryPreOperator returns UnaryOperator:
	NOT='!' 
;
	
ComparingEQNEQOperator returns ComparingOperator:
	EQUAL='==' | UNEQUAL='!=' 
;	

Cons returns LiteralExpression:
	cons=ConsPred "in" "{" litsleft=LitList "}" | cons=LiteralExpression 
;

ConsPred returns LiteralExpression:
	("part(" INT "," STRING "," LiteralExpression ")") | LiteralExpression 
;

LitList:
	(parameters+=XLiteral (',' (parameters+=XLiteral | '...'))*);

Pred returns Constraint:
	predName=ID "(" parList=SuParList? ");"
;

SuParList:
	(parameters+=SuPar (',' parameters+=SuPar)*)
;

SuPar:
	{SuPar} (val=ConsPred | '_')
;

Object returns SuperType:
	{Object} name=ID
;
