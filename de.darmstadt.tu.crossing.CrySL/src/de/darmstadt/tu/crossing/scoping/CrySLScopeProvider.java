/*
 * generated by Xtext 2.10.0
 */
package de.darmstadt.tu.crossing.scoping;

import java.util.List;
import java.util.ArrayList;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.util.EcoreUtil;

import org.eclipse.xtext.common.types.JvmExecutable;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmAnyTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.impl.TypesFactoryImpl;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.SimpleScope;

import de.darmstadt.tu.crossing.crySL.Domainmodel;
import de.darmstadt.tu.crossing.crySL.ForbiddenMethod;
import de.darmstadt.tu.crossing.crySL.Method;
import de.darmstadt.tu.crossing.crySL.Parameter;
import de.darmstadt.tu.crossing.crySL.AnyParameterType;

import de.darmstadt.tu.crossing.crySL.CrySLPackage;
import org.eclipse.xtext.common.types.TypesPackage;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class CrySLScopeProvider extends AbstractCrySLScopeProvider {

	@Override
	public IScope getScope(final EObject context, final EReference reference) {
		IScope scope = polymorphicFindScopeForReferenceName(context, reference);
		if (scope == null)
			scope = delegateGetScope(context, reference);
		if (scope == null)
			scope = IScope.NULLSCOPE;
		return handleGenericTypes(context, reference, scope);
	}


	/**
	 * A *class under specification* (SPEC, hereafter) can be generic and thus
	 * require Specification of type parameter, which should be available as
	 * types for objects and forbidden methods.
	 * The SPEC is represented by Xtype's `JvmTypeReference` and thus the type
	 * parameters as `JvmArgumentTypeReference`, which may produce an
	 * `JvmParameterizedTypeReference` with a type field of type `JvmType`,
	 * according to its parser rule[1].
	 * If the class, that SPEC refers to, is found on the classpath and is
	 * actually an generic type,
	 * then SPEC.javaType.type will be an instance of `JvmGenericType`.
	 * This class provides the methods `getTypeParameters()`, returning each
	 * `JvmTypeParameter`, which are subtypes of JvmType [2].
	 * We can therefore bring those into Scope for each `JvmTypeReference`'s
	 * `type` field.
	 *
	 *
	 * [1]: https://github.com/eclipse/xtext-extras/raw/master/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/Xtype.xtext
	 * [2]: https://www.javadoc.io/doc/org.eclipse.xtext/org.eclipse.xtext.common.types/latest/index.html
	* */
	IScope handleGenericTypes(EObject context, EReference reference, IScope scope) {
		if(reference != TypesPackage.Literals.JVM_PARAMETERIZED_TYPE_REFERENCE__TYPE)
			return scope;

		// Scope for Domainmodel.javaType
		if(context.eContainer() instanceof Domainmodel)
			return scope;

		Domainmodel model =
			(Domainmodel) (EcoreUtil.getRootContainer(context));
		// SPEC class is not generic
		if(!(model.getJavaType().getType() instanceof JvmGenericType))
			return scope;
		// Add all JvmTypeParameter's to the scope
		JvmGenericType clazz =
			(JvmGenericType) model.getJavaType().getType();
		List<IEObjectDescription> scopeElements =
			new ArrayList<>(clazz.getTypeParameters().size());
		for(JvmTypeParameter parameter : clazz.getTypeParameters())
			scopeElements.add(EObjectDescription.create(parameter.getName(), parameter));
		return new SimpleScope(scope, scopeElements);
	}

	/**
	 * Returns Scope of a ForbiddenMethod.
	 *
	 * The scope consists of the simpleName of a Method and a a reference to the
	 * actual method, that match the specified parameters of the method.
	 * */
	IScope scope_ForbiddenMethod_method(ForbiddenMethod method , EReference reference) {
		try {
			Domainmodel model = (Domainmodel) EcoreUtil.getRootContainer(method);
			JvmGenericType jvmType = (JvmGenericType) model.getJavaType().getType();
			List<JvmTypeReference> parameters
				= method.getParameters();
			return new SimpleScope(
				getDescriptionForMatchingMethods(jvmType, parameters));
		}
		catch(ClassCastException e) { debug(e); }
		catch(Exception e) { debug(e); }
		return IScope.NULLSCOPE;
	}

	/**
	 * Returns Scope of a Method.
	 *
	 * The scope consists of the simpleName of a Method and a reference to the
	 * actual method, that match the specified parameters of the method.
	 * Multiple methods may match the parameters, since a Wildcard parameter (`_`)
	 * could have been used.
	 * The Linking Provider will eventually pick the first matching one.
	 * An Aplication has to therefore make sure to consider those matching
	 * alternatives.
	 * */
	public IScope scope_Method_method(Method method, EReference reference)
	{
		try {
			Domainmodel model = (Domainmodel) EcoreUtil.getRootContainer(method);
			JvmGenericType jvmType = (JvmGenericType) model.getJavaType().getType();
			List<JvmTypeReference> parameters =
				resolveTypeFromObject(method.getParameters());
			return new SimpleScope(
				getDescriptionForMatchingMethods(jvmType, parameters));
		}
		catch(ClassCastException e) { debug(e); }
		catch(Exception e) { debug(e); }
		return IScope.NULLSCOPE;
	}


	/**
	 * Returns a List of EObjectDescription's of Methods, matching the given Parameters.
	 * */
	public List<IEObjectDescription> getDescriptionForMatchingMethods( JvmGenericType type, List<JvmTypeReference> parameters )
	{
		List<IEObjectDescription> d = new ArrayList<IEObjectDescription>(2);
		for( JvmExecutable method : getMethods(type) ) {
			if(!matchingParameters(method, parameters)) continue;
			d.add(EObjectDescription.create(method.getSimpleName(), method));
		}
		for( JvmExecutable constructor : type.getDeclaredConstructors() ) {
			if(!matchingParameters(constructor, parameters)) continue;
			d.add(EObjectDescription.create(constructor.getSimpleName(), constructor));
		}
		return d;
	}

	protected List<JvmTypeReference> resolveTypeFromObject(List<Parameter> parameters)
	{
		List<JvmTypeReference> ret = new ArrayList<>(parameters.size());
		for( Parameter p : parameters )
			if(p instanceof AnyParameterType)
				ret.add( TypesFactoryImpl.init().createJvmAnyTypeReference());
			else
				ret.add(p.getValue().getType());
		return ret;
	}

	protected boolean matchingParameters(JvmExecutable a, List<JvmTypeReference> b)
	{
		List<JvmFormalParameter> params = a.getParameters();
		if(params.size() != b.size()) return false;
		List _a = new ArrayList<>(params.size());
		for(JvmFormalParameter fp : params)
			_a.add(fp.getParameterType());
		return matchingParameters(_a, b);
	}

	protected boolean matchingParameters(List<JvmTypeReference> a, List<JvmTypeReference> b)
	{
		if(a.size() != b.size()) return false;
		for(int i = 0; i < a.size(); i++) {
			if(a.get(i) instanceof JvmAnyTypeReference || b.get(i) instanceof JvmAnyTypeReference)
				continue;
			if(!a.get(i).getIdentifier().equals(b.get(i).getIdentifier()))
				return false;
		}
		return true;
	}

	protected List<JvmExecutable> getMethods(JvmGenericType type)
	{
		List<JvmExecutable> methods = new ArrayList<>();
		for( JvmExecutable e : type.getDeclaredOperations() )
			methods.add(e);
		if(type.getExtendedClass() != null)
			methods.addAll(getMethods((JvmGenericType) type.getExtendedClass().getType()));
		for (JvmTypeReference superType : type.getExtendedInterfaces())
			methods.addAll(getMethods((JvmGenericType) superType.getType()));
		return methods;
	}

	private static void debug(Object o)
	{
		// String msg = o == null ? "null" : o.toString();
		// try {
		// 	(new java.io.FileWriter("/var/log/crysl-ls.log", true))
		// 		.append(msg)
		// 		.append('\n')
		// 		.close();
		// } catch (java.io.IOException e) {}
	}
}
