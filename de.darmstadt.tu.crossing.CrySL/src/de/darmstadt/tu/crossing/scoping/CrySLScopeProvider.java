/*
 * generated by Xtext 2.10.0
 */
package de.darmstadt.tu.crossing.scoping;

import java.util.List;
import java.util.LinkedList;
// Most lists are expected to be rather short and mostly insertions and
// simple iterations are requiered, thus use LinkedList with low constant costs

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.util.EcoreUtil;

import org.eclipse.xtext.common.types.JvmExecutable;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmAnyTypeReference;
import org.eclipse.xtext.common.types.impl.TypesFactoryImpl;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.SimpleScope;

import de.darmstadt.tu.crossing.crySL.Domainmodel;
import de.darmstadt.tu.crossing.crySL.ForbiddenMethod;
import de.darmstadt.tu.crossing.crySL.Method;
import de.darmstadt.tu.crossing.crySL.Parameter;
import de.darmstadt.tu.crossing.crySL.AnyParameterType;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class CrySLScopeProvider extends AbstractCrySLScopeProvider {

	@Override
	public IScope getScope(final EObject context, final EReference reference) {
		IScope scope = polymorphicFindScopeForReferenceName(context, reference);
		if (scope == null)
			scope = delegateGetScope(context, reference);
		return scope;
	}
	
	
	/**
	 * Returns Scope of a ForbiddenMethod.
	 *
	 * The scope consists of the simpleName of a Method and a a reference to the
	 * actual method, that match the specified parameters of the method.
	 * */
	IScope scope_ForbiddenMethod_method(ForbiddenMethod method , EReference reference) {
		try {
			Domainmodel model = (Domainmodel) EcoreUtil.getRootContainer(method);
			JvmGenericType jvmType = (JvmGenericType) model.getJavaType().getType();
			List<JvmTypeReference> parameters
				= method.getParameters();
			return new SimpleScope(
				getDescriptionForMatchingMethods(jvmType, parameters));
		}
		catch(ClassCastException e) { debug(e.toString()); }
		catch(Exception e) { debug(e.toString()); }
		return IScope.NULLSCOPE;
	}

	/**
	 * Returns Scope of a Method.
	 *
	 * The scope consists of the simpleName of a Method and a reference to the
	 * actual method, that match the specified parameters of the method.
	 * Multiple methods may match the parameters, since a Wildcard parameter (`_`)
	 * could have been used.
	 * The Linking Provider will eventually pick the first matching one.
	 * An Aplication has to therefore make sure to consider those matching
	 * alternatives.
	 * */
	public IScope scope_Method_method(Method method, EReference reference)
	{
		try {
			Domainmodel model = (Domainmodel) EcoreUtil.getRootContainer(method);
			JvmGenericType jvmType = (JvmGenericType) model.getJavaType().getType();
			List<JvmTypeReference> parameters =
				resolveTypeFromObject(method.getParameters());
			return new SimpleScope(
				getDescriptionForMatchingMethods(jvmType, parameters));
		}
		catch(ClassCastException e) { debug(e.toString()); }
		catch(Exception e) { debug(e.toString()); }
		return IScope.NULLSCOPE;
	}


	/**
	 * Returns a List of EObjectDescription's of Methods, matching the given Parameters.
	 * */
	public List<IEObjectDescription> getDescriptionForMatchingMethods( JvmGenericType type, List<JvmTypeReference> parameters )
	{
		List<IEObjectDescription> d = new LinkedList<IEObjectDescription>();
		for( JvmExecutable method : getMethods(type) ) {
			if(!matchingParameters(method, parameters)) continue;
			d.add(EObjectDescription.create(method.getSimpleName(), method));
		}
		for( JvmExecutable constructor : type.getDeclaredConstructors() ) {
			if(!matchingParameters(constructor, parameters)) continue;
			d.add(EObjectDescription.create(constructor.getSimpleName(), constructor));
		}
		return d;
	}

	protected List<JvmTypeReference> resolveTypeFromObject(List<Parameter> parameters)
	{
		List<JvmTypeReference> ret = new LinkedList<>();
		for( Parameter p : parameters )
			if(p instanceof AnyParameterType)
				ret.add( TypesFactoryImpl.init().createJvmAnyTypeReference());
			else
				ret.add(p.getValue().getType());
		return ret;
	}

	protected boolean matchingParameters(JvmExecutable a, List<JvmTypeReference> b)
	{
		List<JvmFormalParameter> params = a.getParameters();
		if(params.size() != b.size()) return false;
		List _a = new LinkedList<>();
		for(JvmFormalParameter fp : params)
			_a.add(fp.getParameterType());
		return matchingParameters(_a, b);
	}

	protected boolean matchingParameters(List<JvmTypeReference> a, List<JvmTypeReference> b)
	{
		if(a.size() != b.size()) return false;
		for(int i = 0; i < a.size(); i++) {
			if(a.get(i) instanceof JvmAnyTypeReference || b.get(i) instanceof JvmAnyTypeReference)
				continue;
			if(!a.get(i).getIdentifier().equals(b.get(i).getIdentifier()))
				return false;
		}
		return true;
	}

	protected List<JvmExecutable> getMethods(JvmGenericType type)
	{
		List<JvmExecutable> methods = new LinkedList<>();
		for( JvmExecutable e : type.getDeclaredOperations() )
			methods.add(e);
		if(type.getExtendedClass() != null)
			methods.addAll(getMethods((JvmGenericType) type.getExtendedClass().getType()));
		for (JvmTypeReference superType : type.getExtendedInterfaces())
			methods.addAll(getMethods((JvmGenericType) superType.getType()));
		return methods;
	}

	private static void debug(String msg)
	{
		// try {
		// 	(new java.io.FileWriter("/var/log/crysl-scoping.log", true))
		// 		.append(msg)
		// 		.append('\n')
		// 		.close();
		// } catch (java.io.IOException e) {}
	}
}
